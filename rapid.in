#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <inttypes.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"

#include "driver/twai.h"
#include "tinyusb.h"
#include "tusb_cdc_acm.h"
#include "sdkconfig.h"

#include "omni_pins.h"

// --------------------------------------------------------------------
// Global state
// --------------------------------------------------------------------
// Bandera 'volatile' para asegurar que todas las tareas lean el cambio inmediato
static volatile bool driver_access_allowed = false; 
static bool can_installed = false;
static int current_bitrate = 500;

static QueueHandle_t rx_event_queue = nullptr;
static QueueHandle_t usb_cmd_queue = nullptr;

enum RxEvent { RX_FRAME };

struct UsbCmd {
    char buf[64];
};

// --------------------------------------------------------------------
// TWAI DRIVER CONTROL
// --------------------------------------------------------------------
static void twai_init(int bitrate_kbps)
{
    if (can_installed) return;

    twai_general_config_t g_config = TWAI_GENERAL_CONFIG_DEFAULT(TX_CAN, RX_CAN, TWAI_MODE_NORMAL);
    g_config.tx_queue_len = 20;
    g_config.rx_queue_len = 20;
    g_config.alerts_enabled = TWAI_ALERT_RX_DATA | TWAI_ALERT_BUS_OFF | TWAI_ALERT_BUS_ERROR;

    twai_timing_config_t t_config;

    switch (bitrate_kbps) {
        case 100: t_config = TWAI_TIMING_CONFIG_100KBITS(); break;
        case 125: t_config = TWAI_TIMING_CONFIG_125KBITS(); break;
        case 250: t_config = TWAI_TIMING_CONFIG_250KBITS(); break;
        case 500:
        default:  t_config = TWAI_TIMING_CONFIG_500KBITS(); break;
        case 800: t_config = TWAI_TIMING_CONFIG_800KBITS(); break;
        case 1000: t_config = TWAI_TIMING_CONFIG_1MBITS(); break;
    }

    twai_filter_config_t f_config = TWAI_FILTER_CONFIG_ACCEPT_ALL();

    if (twai_driver_install(&g_config, &t_config, &f_config) == ESP_OK) {
        if (twai_start() == ESP_OK) {
            can_installed = true;
            current_bitrate = bitrate_kbps;
            // Habilitamos el acceso a las otras tareas
            driver_access_allowed = true;
        } else {
            twai_driver_uninstall();
        }
    }
}

static void twai_deinit()
{
    if (!can_installed) return;

    // 1. Prohibir acceso: Las tareas dejaran de llamar a funciones API
    driver_access_allowed = false;

    // 2. Esperar un tiempo prudencial para asegurar que las tareas rx/alert 
    // han salido de cualquier bloqueo y estan en el bucle de espera.
    // Esto evita el crash "spinlock" o "load prohibited".
    vTaskDelay(pdMS_TO_TICKS(100));

    // 3. Ahora es seguro matar el driver
    twai_stop();
    twai_driver_uninstall();
    can_installed = false;
}

static void twai_change_bitrate(int new_br)
{
    if (can_installed) {
        twai_deinit();
    }
    twai_init(new_br);
}

// --------------------------------------------------------------------
// TRANSMISSION
// --------------------------------------------------------------------
static void slcan_to_can(const char *line)
{
    // Si el driver se esta borrando o no existe, no hacemos nada
    if (!driver_access_allowed) return;

    if (line[0] != 't' && line[0] != 'T') return;

    bool extended = (line[0] == 'T');
    int id_len = extended ? 8 : 3;

    twai_message_t msg = {};
    msg.extd = extended;

    char id_buf[9] = {0};
    memcpy(id_buf, line + 1, id_len);
    msg.identifier = strtol(id_buf, nullptr, 16);

    msg.data_length_code = line[1 + id_len] - '0';
    if (msg.data_length_code > 8) msg.data_length_code = 8;

    const char *data_ptr = line + 2 + id_len;
    for (int i = 0; i < msg.data_length_code; i++) {
        char b[3] = { data_ptr[i*2], data_ptr[i*2+1], 0 };
        msg.data[i] = (uint8_t)strtol(b, nullptr, 16);
    }

    twai_transmit(&msg, pdMS_TO_TICKS(10));
}

// --------------------------------------------------------------------
// TASKS
// --------------------------------------------------------------------

void twai_alert_task(void *arg)
{
    uint32_t alerts;
    while (true)
    {
        // Protección: Si estamos cambiando configuración, esperar.
        if (!driver_access_allowed) {
            vTaskDelay(pdMS_TO_TICKS(20));
            continue;
        }

        // Timeout corto para revisar la bandera driver_access_allowed frecuentemente
        if (twai_read_alerts(&alerts, pdMS_TO_TICKS(50)) == ESP_OK)
        {
            if (alerts & TWAI_ALERT_RX_DATA)
            {
                RxEvent evt = RX_FRAME;
                xQueueSend(rx_event_queue, &evt, 0);
            }
        }
    }
}

void can_rx_task(void *arg)
{
    char out[64];
    RxEvent evt;

    while (true)
    {
        // Esperamos evento de la cola (viene de Alert task)
        if (xQueueReceive(rx_event_queue, &evt, portMAX_DELAY))
        {
            // Doble chequeo de seguridad
            if (!driver_access_allowed) continue;

            twai_message_t m;
            // Mientras haya mensajes y el driver siga activo
            while (driver_access_allowed && twai_receive(&m, 0) == ESP_OK)
            {
                int n = 0;
                if (m.extd)
                    n += sprintf(out, "T%08" PRIX32 "%d", m.identifier, m.data_length_code);
                else
                    n += sprintf(out, "t%03" PRIX32 "%d", m.identifier, m.data_length_code);

                for (int i = 0; i < m.data_length_code; i++)
                    n += sprintf(out + n, "%02X", m.data[i]);

                out[n++] = '\r';

                if (tud_cdc_connected()) {
                    tud_cdc_write(out, n);
                    tud_cdc_write_flush();
                }
            }
        }
    }
}

extern "C" void tud_cdc_rx_cb(uint8_t itf)
{
    static char buffer[64];
    static int pos = 0;

    while (tud_cdc_available())
    {
        char c = tud_cdc_read_char();

        if (c == '\r' || c == '\n')
        {
            if (pos > 0)
            {
                UsbCmd cmd;
                if (pos > 63) pos = 63;
                memcpy(cmd.buf, buffer, pos);
                cmd.buf[pos] = 0;

                xQueueSendFromISR(usb_cmd_queue, &cmd, NULL);
                pos = 0;
            }
        }
        else if (pos < (int)sizeof(buffer) - 1)
        {
            buffer[pos++] = c;
        }
    }
}

void usb_cmd_task(void *arg)
{
    UsbCmd cmd;
    while (true)
    {
        if (xQueueReceive(usb_cmd_queue, &cmd, portMAX_DELAY))
        {
            const char *buf = cmd.buf;

            switch (buf[0])
            {
                case 'O': // Open
                    twai_init(current_bitrate);
                    break;

                case 'C': // Close
                    twai_deinit();
                    break;

                case 'S': // Set bitrate
                {
                    int br = 500;
                    switch(buf[1]) {
                        case '0': br = 10; break; 
                        case '1': br = 20; break; 
                        case '2': br = 50; break; 
                        case '3': br = 100; break;
                        case '4': br = 125; break;
                        case '5': br = 250; break;
                        case '6': br = 500; break;
                        case '7': br = 800; break;
                        case '8': br = 1000; break;
                    }
                    twai_change_bitrate(br);
                    break;
                }

                case 't':
                case 'T':
                    slcan_to_can(buf);
                    break;
            }

            // ACK
            if (tud_cdc_connected()) {
                tud_cdc_write_char('\r');
                tud_cdc_write_flush();
            }
        }
    }
}

void tinyusb_task(void *param)
{
    while (true)
    {
        tud_task();
        vTaskDelay(pdMS_TO_TICKS(5));
    }
}

// --------------------------------------------------------------------
// MAIN
// --------------------------------------------------------------------
extern "C" void app_main()
{
    tinyusb_config_t tusb_cfg = {};
    tusb_cfg.external_phy = false;
    ESP_ERROR_CHECK(tinyusb_driver_install(&tusb_cfg));

    rx_event_queue = xQueueCreate(20, sizeof(RxEvent));
    usb_cmd_queue  = xQueueCreate(10, sizeof(UsbCmd));

    xTaskCreate(twai_alert_task, "twai_alert", 4096, nullptr, 5, nullptr);
    xTaskCreate(can_rx_task,     "can_rx",     4096, nullptr, 5, nullptr);
    xTaskCreate(usb_cmd_task,    "usb_cmd",    4096, nullptr, 5, nullptr);
    xTaskCreate(tinyusb_task,    "tinyusb",    4096, nullptr, 5, nullptr);

    // AUTO-DETECT WORKAROUND:
    // Iniciamos el CAN directamente al arrancar a 500kbps (comun).
    // Asi Linux puede hacer 'slcand' inmediatamente sin enviar 'O' primero.
    printf("Auto-starting CAN at 500kbps...\n");
    twai_init(500);
}